## 取り組んだ課題一覧
- フルスタックエンジニアが教える 即戦力Railsエンジニア養成講座

## わかったこと
- REPL（Read Eval Print Loop）入力→コード評価→表示を繰り返すツール　pryはirbに比べるとインデント調整や色付けなど行ってくれるため読みやすい
- 以下復習や学んだこと
- シンボルについて
  - 内部的には数値(整数)で扱われる
  - 同じシンボルは同じオブジェクトを指すため、メモリの消費が少なく済む
  - ハッシュと組み合わせて使用し、ハッシュのキーにシンボルを使用できる
- 数値について
  - integerやfloatなど異なる型での演算を行うと実数寄りになる（integerとfloatだとfloatの結果が出力される）
  - ブロック（処理の塊）
- Array(配列)
  - '%w'記法：スペースで区切って文字を記述するとそれぞれを要素とみなしてくれる
  - 別の記号で囲んでも良いがブラケットが推奨されている
  - 小文字w→シングル、大文字W→ダブルクオートの囲み扱いとなるため式展開が使える
  - mapメソッドは新しい配列を返す
- ハッシュオブジェクトについて
  - キーとバリューの組み合わせでデータを表現する
  - キーを文字列で表現したい場合にはシンボルの記法は使えない
  - ハッシュのバリューには任意のオブジェクトを格納できるため、階層構造を作ることができる
  - ハッシュのキーを指定して特定の値を代入することで値を書き換えることができる
  - deleteメソッドで一部のキーバリューを削除することができる
- Range(範囲)
  - .の数２→最後の値を含む、.の数３→最後の値を含まない
  - eachメソッドを扱ってそれぞれの値に処理を行うことができる
- Time(時刻),Date(日付), DateTime(日時)
  -`now`で現在時刻を取得、`zone`ではタイムゾーンを取得
  - タイムゾーンはシステム実行環境のタイムゾーンが使用されるため、サーバーのタイムゾーンなど意識する
  - Time.newで任意日時のタイムオブジェクト生成が可能
  - strftimeでフォーマットも自由に指定可能
  - DateクラスはDateライブラリを読み込む必要がある
- bool(真偽)
  - !(変数など)で逆の値!(true) →falseなど
- 変数、定数について
  - 変数：小文字、定数：大文字
  - Rubyでは定数でも値を変更できてしまうが値の再代入は行われない想定のものなので行ってはいけない
- ヒアドキュメント、コメント
  - コメント
    - `#` で単一行 `=begin`,`=end`で複数行
  - ヒアドキュメント
    - `EOS` EndOfString よく使われる
    - `<<-EOS`の記述方法はインデントを揃えるときなどに使える
- 条件分岐（if,unless）
  - `nil`, `false`は偽と評価される
  - 後置if, 後置unless：一行で記述したいときなどスッキリかける
  - 三項演算子を利用することでもっとスッキリかけることもある
-　擬似変数・論理演算子
  - 擬似変数
    - `true`, `false`, `nil`
  - 論理演算子
    - `true && false`と`false && true`や、`true || false`と`false || true`では行われる処理は異なる。
    - `true`で返された値を代入することもできる
    - `val ||= 'new value'` はvarが`nil`, `false`の場合に値を代入する
    - `and` `or` `not`は記号での記述が推奨されている
- case文
  - if文をダラダラ書かないために使える
- メソッド
  - Rubyのインデントはスペース２つが主
  - 呼び出す時はメソッドより下で呼び出す、定義される前に呼ぶとエラーになるため
  - 仮引数にデフォルト値を設定する事ができ、デフォルト値があるときには引数を省略できる
  - カリ引数をハッシュのような形式で記述すると、呼び出す際にラベルで呼び出せるため、何を渡して呼び出しているのか分かりやすくなる。並び替えてもキーに合わせて引数をセットして正常に動作してくれるため便利
  - 可変長引数`*引数`で記述する(※１つで配列、２つでハッシュで渡される)
  - 引数の定義は必須、オプション、可変長の順で仮引数を定義すると良い
- Procオブジェクト
  - ブロックをオブジェクト化したもの
  - Procに渡したブロックだとブロック外の変数が参照できる
  - 変数未定義のものをprocに渡すと`call`した際にエラーとなる（渡せてしまうので注意）
  - procに渡す前に変数は定義する
- yield
  - メソッドで呼び出しの渡されたブロックをメソッドで実行する際に使用
  - ブロックパラメーターとしてyieldの引数がセットされる
  - 任意のタイミングで実行できる
  - 仮引数に&をつけることでProcオブジェクトとして受け取る事ができる`test(&proc)`のように　仮引数の定義は一番最後にしなければならない
  - yieldはProcを受け取る記法を省略したものとなる
  - `block_given`メソッドで渡されたかどうかを確認する事ができる
- クラス/イニシャライザ/アクセサについて
  - クラス名はキャメルケース
  - initializeメソッド：オブジェクトが生成される際に自動的に呼び出されるので初期化として使う
  - インスタンス変数：@~で記述したもの`@name`など
  - インスタンス変数にアクセスするためのメソッドが必要→アクセサメソッドで自動で用意してくれる(`attr_accessor`, `attr_reader`, `attr_writer`)
  - `initialize`メソッドで初期化されない場合は`nil`で自動的に行われる
- クラスメソッド
  - オブジェクトを生成せずに呼び出す事ができるメソッド
    - `self.メソッド名`、 `class << self end`でクラスメソッドを定義できる
    - 前者は単一メソッド、後者は複数メソッドを定義する際に利用できる
    - クラスメソッドはオブジェクトからは呼び出せない（インスタンスメソッドのようには使えない）
- クラス変数
  - クラス内に定義するメソッド。`@@`で定義でき、インスタンスメソッド・クラスメソッドどちらからも参照できる。
- インスタンスメソッド
  - クラス内の他メソッドやオブジェクトから呼び出す。
  - インスタンス変数にアクセス可能
  - `public`,`private`,`protected`
  - デフォルトは`public`
  - `private`はクラス内からでないと呼び出せないため、`user.private_name`の呼び出し方もできない。`self`の記載もしない（関数形式）
　- `protected`, `private`の違いは自身をレシーバーとして呼び出せるかどうか（`self.~`が使えるかどうか）
  - 破壊的メソッドを利用する際には気を付ける。元のオブジェクトが書き換えられてしまうため
- クラス継承について
  - 共通定義を元クラスに記載しておき、個別の定義を継承先で定義する
  - メソッドのオーバーライドが可能（引数は関係なくメソッド名が同じであれば可能となる）
- モジュールについて
  - メソッドや定数を定義できるが、モジュールからオブジェクトを生成することはできない

## 次やること
- フルスタックエンジニアが教える 即戦力Railsエンジニア養成講座(続き)

## 感じたこと
- チェリー本で復習した事が結構抜け落ちていたので基礎を学び直して課題に進めるようにインプットを進めていきたい

## 学習時間
- 　Today：2.5h
- 　Total：277.5h